# Prompt Valet Architecture (Seed Version)

## Overview
Prompt Valet consists of several coordinated components:

- **Inbox Directory** — entry point for prompts.
- **Codex Watcher** — executes prompts.
- **Repo Auto-Cloner** — ensures repos exist.
- **Branch Tree Builder** — keeps inbox structured by branch.
- **Codex Runner** — performs the heavy lifting.
- **Processed Directory** — archive of completed prompts.
- **File Server (Optional)** — provides a UI surface via Copyparty.

## Component Interaction Flow

1. A file appears in `inbox/<repo>/<branch>/`.
2. The watcher inspects it and identifies the repo + branch context.
3. Missing repos are cloned into `/srv/repos/<repo>/`.
4. The prompt is passed to the Codex runner.
5. The runner produces a PR or commit depending on configuration.
6. The prompt file is moved to `processed/<repo>/<branch>/`.
7. Logs are written to the chosen log directory.

## Config Interaction
All internal components read from a unified config file at `/srv/prompt-valet/config/prompt-valet.yaml`.  
The config determines:
- inbox path
- processed path
- git defaults
- file server mode
- branch filtering modes
- runner command and args

## Systemd Integration
Systemd units typically manage:
- codex watcher (long-running)
- tree builder (timer or periodic)

These units will be documented more fully in Phase 2.

## Python Structure Analysis (Generated by Agent)

### `scripts/codex_watcher.py`
- Constants at the top pin the inbox/processed roots to `/srv/copyparty/inbox` and `/srv/copyparty/processed`, the repo root to `/srv/repos`, and the runtime config path to `/srv/prompt-valet/config/prompt-valet.yaml`.
- `load_config()` merges `DEFAULT_CONFIG` with the YAML file at `/srv/prompt-valet/config/prompt-valet.yaml` via `yaml.safe_load()`, falling back to defaults when the file is absent or malformed.
- The watcher path logic lives in `_split_inbox_path()` and `_ensure_repo_present()`: prompts are validated by repo/branch/job, repos are checked for `.git`, optionally cleaned when `cleanup_non_git_dirs` is true, and auto-cloned via `git clone` when `auto_clone_missing_repos` is enabled and a `git_default_owner` can build a remote URL over HTTPS or SSH.
- `PromptHandler` (a `watchdog` `FileSystemEventHandler`) feeds created or moved `.prompt.md` files into `process_prompt_file()`, which performs the control flow: fetch → checkout → pull → new branch creation → Codex execution → git status/add/commit/push → optional `gh pr create` → move the prompt to the processed directory.
- Codex is invoked through `codex exec` with `--skip-git-repo-check`, `--cd` into the repo, `--output-last-message`, `--model` set to `gpt-5.1-codex-mini`, and `--sandbox danger-full-access`; output is stored under `<repo>/docs/AGENT_RUNS/`.

### `scripts/rebuild_inbox_tree.py`
- The script reads `/srv/prompt-valet/config/prompt-valet.yaml` via `yaml.safe_load()`, merging into `DEFAULT_CONFIG` so tree-builder and watcher defaults stay aligned.
- `main()` ensures the inbox root exists, logs the loaded `tree_builder` values, runs `build_from_local_repos()` to iterate real git repos under `/srv/repos/`, lists remote branches, filters them via `filter_branches_for_inbox()` (whitelist/blacklist/name blacklist, safe path rules) and creates `inbox/<repo>/<branch>` directories via `ensure_inbox_dir()`.
- After branch creation, optional `eager_repos` mode can ensure empty inbox roots exist for every repo; then `clean_inbox_branches()` and `clean_inbox_roots()` remove stale branch folders (writing `ERROR.md` markers) and orphaned repo roots that have no counterpart under `/srv/repos/`.
- Control is linear: load config → build directories → clean extras, with helper functions isolating git discovery, filtering, and path cleanup.

### Codex Worker Repository Hygiene

The Codex worker clone on the runner is ephemeral. Codex runs always start from a clean checkout of the configured branch. If the watcher detects a dirty working tree, it automatically performs:

1. `git fetch --prune`
2. `git reset --hard origin/<branch>`
3. `git clean -fdx`

This guarantees that each run executes against a known-good state and prevents stale or manual changes from breaking automation.
