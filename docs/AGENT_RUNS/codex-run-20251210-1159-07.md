Queue-aware runtime now wraps the existing watcher/runner flow around the filesystem-backed job queue and documents/exercises the new flag surface.

- Added `scripts/queue_runtime.py` (see `scripts/queue_runtime.py:1-210`) to create job directories (`.queue/jobs/<job_id>`), persist `meta.json`/`state`, and expose `enqueue|get_next|mark_*|requeue` helpers plus helpers to skip malformed records.
- Reworked `scripts/codex_watcher.py` so `start_jobs_from_running` optionally enqueues new jobs (`scripts/codex_watcher.py:583-711`), the executor loop archives prompts and enforces retries (`scripts/codex_watcher.py:1368-1421`), and `main` now toggles between direct and queue-enabled modes (`scripts/codex_watcher.py:1428-1571`), emitting the `job.*` events around each transition.
- Surface new configuration keys and docs so humans see `pv_root`, `failed`, and the `queue` block (`config/prompt-valet.yaml:3-50`, `docs/configuration.md:93-121`, `docs/job_queue_overview.md:75-79`, `README.md:1-5`), matching the documented Q1/Q2/Q3 story.
- Added regression coverage for the runtime and watcher integration (`tests/test_queue_runtime.py:1-110`, `tests/test_queue_watcher.py:1-205`) to validate enqueue ordering, executor success/retries, and failure archival policy.

Tests: `pytest -q`

Suggestions:
1. Verify the systemd/service side still matches the new queue mode (e.g., start `codex_watcher`/executor with `queue.enabled=true` and ensure no duplicate executions or missing units).
2. Consider adding a maintenance/monitoring hook for the `.queue` tree so you can inspect leftover jobs or alert when many retryable failures accumulate.