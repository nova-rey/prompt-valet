I tightened the UI refresh plumbing so text-only updates only happen once per distinct value, moved every periodic timer to a sane ≥1 s cadence, and made the Services view respect manual refresh plus a one-shot service-down state instead of endlessly flickering.

- Added `_should_update` plus a shared cache in `prompt_valet/ui/app.py:45` and wired `_set_text_if_changed` through it so semantic string equality now gates every label mutation; the submit target panel also no longer stomps `target_status_label` with both “loading” and final text in a single cycle (`prompt_valet/ui/app.py:967`), and `_refresh_targets` now runs via `_schedule_async` plus a 2 s timer defined at `prompt_valet/ui/app.py:1187-1211`.
- Reworked the Services card so the Refresh button fires `_schedule_async`, connectivity and service timers stay ≥2 s, and a service-down message (`“Service not running…”`) plus disabled auto-refresh are shown/held until either the connectivity listener flips true again or the user manually refreshes; the full flow lives around `prompt_valet/ui/app.py:1211-1525`.
- Added `/healthz` and `/status` stubs feeding deterministic counts/roots so the regression test can drive the UI without real backend services (`tests/fixtures/stub_api.py:158-194`) and introduced `tests/test_ui_strobe.py:1-62` to exercise the new guard by repeatedly running `_refresh_services`/`_refresh_targets`.

Tests: `pytest tests/test_ui_strobe.py`

Next: once you’re ready, consider running the broader pytest suite to cover the remaining control-plane surfaces.