- Unified both watcher scripts around `/srv/prompt-valet/config/prompt-valet.yaml`, added `DEFAULT_CONFIG_PATH`/copy semantics, refreshed the merged defaults (watcher + tree builder), and added the sample template `configs/prompt-valet.yaml:1` so the runtime path and keys are documented in-project (see `scripts/rebuild_inbox_tree.py:34-155` and `scripts/codex_watcher.py:681-738` for the new loader/log behavior).
- Docs now reflect the canonical YAML file: `docs/Filesystem.md:6` mentions the runtime layout, `docs/Architecture.md:24` describes the unified source and loader, `docs/Phase_Roadmap.md:3`, `docs/Prompt_Valet_Overview.md:34`, `docs/Bible.md:18`, `docs/Config_Spec.md:5`, and `docs/AGENT_RUNS/codex-run-20251205-1623-5e5d.md:1` all point at `prompt-valet.yaml` instead of the old names/paths.
- Startup logging now prints `[prompt-valet] loaded config=<path> inbox=<inbox> processed=<processed> git_owner=<owner> git_host=<host> git_protocol=<proto> runner=<cmd>`:
  * `scripts/codex_watcher.py:726-736` records the resolved inbox/processed roots and runner command (`runner=<runner_cmd> exec`).
  * `scripts/rebuild_inbox_tree.py:145-156` uses the same format with `processed=<n/a>` and `runner=<none>`, so both scripts expose the same git owner/host/protocol snapshot (with `<defaults>` when no file is present).
- Tests: `python3 -m py_compile scripts/codex_watcher.py` and `python3 -m py_compile scripts/rebuild_inbox_tree.py` (the plain `python` alias isnâ€™t available in this environment, so I used `python3`).
- Validation: `rg -n watcher.yaml`, `rg -n /etc/codex-runner/config.toml`, and `rg -n /srv/prompt-valet/config/codex-runner.yaml` now return no hits, proving only the new config path remains on disk.

TOML is no longer consulted at runtime; both scripts now load the unified YAML at `/srv/prompt-valet/config/prompt-valet.yaml`.

Next steps:
1. Populate `/srv/prompt-valet/config/prompt-valet.yaml` on the runner with real values (matching the seed in `configs/prompt-valet.yaml`) and restart the services to pick it up.
2. Snapshot or document any live overrides so future checkpoints can verify the runtime file mirrors the repo template.